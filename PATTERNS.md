# Patterns Introduction（设计模式介绍）

## Strategy Pattern（策略模式）
策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

### 应用场景
1. 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。
2. 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。
3. 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。

## Observer Pattern（观察者模式）
观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。
观察者模式提供了一种对象设计，让主题和观察者之间松耦合

## Decorator Pattern（装饰者模式）
装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
装饰者模式主要有Component、ConcreteComponent、Decorator和ConcreteDecorator组成：
1. 抽象组件角色(Component)：定义一个对象接口，以规范准备接受附加责任的对象，即可以给这些对象动态地添加职责。
2. 具体组件角色(ConcreteComponent) :被装饰者，定义一个将要被装饰增加功能的类。可以给这个类的对象添加一些职责。
3. 抽象装饰者(Decorator):维持一个指向构件Component对象的实例，并定义一个与抽象组件角色Component接口一致的接口。
4. 具体装饰者角色（ConcreteDecorator):向组件添加职责。

python 装饰器可以更简单实现装饰者模式